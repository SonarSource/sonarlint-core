/*
 * SonarLint Core - Implementation
 * Copyright (C) 2016-2023 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonarsource.sonarlint.core.tracking;

import java.time.Instant;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import javax.annotation.Nullable;
import org.sonarsource.sonarlint.core.commons.Binding;
import org.sonarsource.sonarlint.core.commons.TextRangeWithHash;
import org.sonarsource.sonarlint.core.event.ServerIssueStatusChangedEvent;
import org.sonarsource.sonarlint.core.event.SonarServerEventReceivedEvent;
import org.sonarsource.sonarlint.core.event.TaintVulnerabilitiesSynchronizedEvent;
import org.sonarsource.sonarlint.core.file.FilePathTranslation;
import org.sonarsource.sonarlint.core.file.FilePathTranslationRepository;
import org.sonarsource.sonarlint.core.repository.branch.MatchedSonarProjectBranchRepository;
import org.sonarsource.sonarlint.core.repository.config.ConfigurationRepository;
import org.sonarsource.sonarlint.core.rpc.protocol.SonarLintRpcClient;
import org.sonarsource.sonarlint.core.rpc.protocol.backend.tracking.TaintVulnerabilityDto;
import org.sonarsource.sonarlint.core.rpc.protocol.backend.tracking.TextRangeWithHashDto;
import org.sonarsource.sonarlint.core.rpc.protocol.client.taint.vulnerability.DidChangeTaintVulnerabilitiesParams;
import org.sonarsource.sonarlint.core.rpc.protocol.common.CleanCodeAttribute;
import org.sonarsource.sonarlint.core.rpc.protocol.common.IssueSeverity;
import org.sonarsource.sonarlint.core.rpc.protocol.common.RuleType;
import org.sonarsource.sonarlint.core.rpc.protocol.common.SoftwareQuality;
import org.sonarsource.sonarlint.core.serverapi.push.IssueChangedEvent;
import org.sonarsource.sonarlint.core.serverapi.push.TaintVulnerabilityClosedEvent;
import org.sonarsource.sonarlint.core.serverapi.push.TaintVulnerabilityRaisedEvent;
import org.sonarsource.sonarlint.core.serverconnection.issues.ServerTaintIssue;
import org.sonarsource.sonarlint.core.storage.StorageService;
import org.sonarsource.sonarlint.core.sync.SynchronizationService;
import org.springframework.context.event.EventListener;

import static java.util.Collections.emptyList;
import static java.util.Collections.emptySet;

public class TaintVulnerabilityTrackingService {
  private final SonarLintRpcClient client;
  private final ConfigurationRepository configurationRepository;
  private final MatchedSonarProjectBranchRepository branchRepository;
  private final SynchronizationService synchronizationService;
  private final StorageService storageService;
  private final FilePathTranslationRepository pathTranslationRepository;

  public TaintVulnerabilityTrackingService(SonarLintRpcClient client, ConfigurationRepository configurationRepository, MatchedSonarProjectBranchRepository branchRepository,
    SynchronizationService synchronizationService, StorageService storageService, FilePathTranslationRepository pathTranslationRepository) {
    this.client = client;
    this.configurationRepository = configurationRepository;
    this.branchRepository = branchRepository;
    this.synchronizationService = synchronizationService;
    this.storageService = storageService;
    this.pathTranslationRepository = pathTranslationRepository;
  }

  public List<TaintVulnerabilityDto> listAll(String configurationScopeId, boolean shouldRefresh) {
    return configurationRepository.getEffectiveBinding(configurationScopeId)
      .map(binding -> loadTaintVulnerabilities(configurationScopeId, binding, shouldRefresh))
      .orElseGet(Collections::emptyList);
  }

  @EventListener
  public void onServerEventReceived(SonarServerEventReceivedEvent eventReceived) {
    var connectionId = eventReceived.getConnectionId();
    var serverEvent = eventReceived.getEvent();
    if (serverEvent instanceof TaintVulnerabilityRaisedEvent) {
      insertIntoStorageAndNotifyClient(connectionId, (TaintVulnerabilityRaisedEvent) serverEvent);
    } else if (serverEvent instanceof TaintVulnerabilityClosedEvent) {
      removeFromStorageAndNotifyClient(connectionId, (TaintVulnerabilityClosedEvent) serverEvent);
    } else if ((serverEvent instanceof IssueChangedEvent)) {
      updateStorageAndNotifyClient(connectionId, (IssueChangedEvent) serverEvent);
    }
  }

  @EventListener
  public void onServerIssueStatusChanged(ServerIssueStatusChangedEvent event) {
    var finding = event.getFinding();
    if (finding instanceof ServerTaintIssue) {
      var taintVulnerability = (ServerTaintIssue) finding;
      var connectionId = event.getConnectionId();
      var projectKey = event.getProjectKey();
      configurationRepository.getBoundScopesByConnection(connectionId, projectKey)
        .forEach(boundScope -> {
          var newCodeDefinition = storageService.connection(connectionId).project(projectKey).newCodeDefinition().read()
            .<Predicate<Instant>>map(definition -> definition::isOnNewCode).orElse(date -> true);
          var pathTranslation = pathTranslationRepository.getPathTranslation(boundScope.getId());
          pathTranslation.ifPresent(translation -> client.didChangeTaintVulnerabilities(
            new DidChangeTaintVulnerabilitiesParams(boundScope.getId(), emptySet(), emptyList(), List.of(toDto(taintVulnerability, newCodeDefinition, translation)))));
        });
    }
  }

  @EventListener
  public void onTaintVulnerabilitiesSynchronized(TaintVulnerabilitiesSynchronizedEvent event) {
    var summary = event.getSummary();
    if (!summary.hasAnythingChanged()) {
      return;
    }
    var connectionId = event.getBoundScope().getConnectionId();
    var newCodeDefinition = storageService.connection(connectionId).project(event.getBoundScope().getSonarProjectKey()).newCodeDefinition().read()
      .<Predicate<Instant>>map(definition -> definition::isOnNewCode).orElse(date -> true);
    var pathTranslation = pathTranslationRepository.getPathTranslation(event.getBoundScope().getId());
    pathTranslation
      .ifPresent(
        translation -> client.didChangeTaintVulnerabilities(new DidChangeTaintVulnerabilitiesParams(event.getBoundScope().getId(), summary.getDeletedTaintVulnerabilityIds(),
          summary.getAddedTaintVulnerabilities().stream().map(taint -> toDto(taint, newCodeDefinition, translation)).collect(Collectors.toList()),
          summary.getUpdatedTaintVulnerabilities().stream().map(taint -> toDto(taint, newCodeDefinition, translation)).collect(Collectors.toList()))));
  }

  private void insertIntoStorageAndNotifyClient(String connectionId, TaintVulnerabilityRaisedEvent event) {
    var newTaintVulnerability = new ServerTaintIssue(
      UUID.randomUUID(),
      event.getKey(),
      false,
      event.getRuleKey(),
      event.getMainLocation().getMessage(),
      event.getMainLocation().getFilePath(),
      event.getCreationDate(),
      event.getSeverity(),
      event.getType(),
      adapt(event.getMainLocation().getTextRange()),
      event.getRuleDescriptionContextKey(),
      event.getCleanCodeAttribute().orElse(null),
      event.getImpacts())
      .setFlows(adapt(event.getFlows()));
    var projectKey = event.getProjectKey();
    storageService.connection(connectionId).project(projectKey).findings().insert(event.getBranchName(), newTaintVulnerability);
    configurationRepository.getBoundScopesByConnection(connectionId, projectKey).forEach(boundScope -> {
      var pathTranslation = pathTranslationRepository.getPathTranslation(boundScope.getId());
      pathTranslation.ifPresent(translation -> client.didChangeTaintVulnerabilities(
        new DidChangeTaintVulnerabilitiesParams(boundScope.getId(), emptySet(), List.of(toDto(newTaintVulnerability, date -> true, translation)), emptyList())));
    });
  }

  private void removeFromStorageAndNotifyClient(String connectionId, TaintVulnerabilityClosedEvent event) {
    var projectKey = event.getProjectKey();
    storageService.connection(connectionId)
      .project(projectKey)
      .findings()
      .deleteTaintIssueBySonarServerKey(event.getTaintIssueKey())
      .ifPresent(deletedId -> configurationRepository.getBoundScopesByConnection(connectionId, projectKey).forEach(boundScope -> client
        .didChangeTaintVulnerabilities(new DidChangeTaintVulnerabilitiesParams(boundScope.getId(), Set.of(deletedId), emptyList(), emptyList()))));
  }

  private void updateStorageAndNotifyClient(String connectionId, IssueChangedEvent event) {
    var projectKey = event.getProjectKey();
    var updatedTaintVulnerabilities = updateTaintIssues(connectionId, projectKey, event.getUserSeverity(), event.getUserType(), event.getResolved(), event.getImpactedIssueKeys());
    if (!updatedTaintVulnerabilities.isEmpty()) {
      configurationRepository.getBoundScopesByConnection(connectionId, projectKey).forEach(boundScope -> {
        var newCodeDefinition = storageService.connection(connectionId).project(projectKey).newCodeDefinition().read()
          .<Predicate<Instant>>map(definition -> definition::isOnNewCode).orElse(date -> true);
        pathTranslationRepository.getPathTranslation(boundScope.getId())
          .ifPresent(translation -> client.didChangeTaintVulnerabilities(new DidChangeTaintVulnerabilitiesParams(boundScope.getId(), emptySet(),
            emptyList(), updatedTaintVulnerabilities.stream().map(taintIssue -> toDto(taintIssue, newCodeDefinition, translation)).collect(Collectors.toList()))));
      });
    }
  }

  private List<ServerTaintIssue> updateTaintIssues(String connectionId, String projectKey, @Nullable org.sonarsource.sonarlint.core.commons.IssueSeverity userSeverity,
    @Nullable org.sonarsource.sonarlint.core.commons.RuleType userType, @Nullable Boolean resolved, List<String> issueKeys) {
    var findingsStorage = storageService.connection(connectionId).project(projectKey).findings();
    return issueKeys.stream().map(issueKey -> findingsStorage.updateTaintIssueBySonarServerKey(issueKey, issue -> {
      if (userSeverity != null) {
        issue.setSeverity(userSeverity);
      }
      if (userType != null) {
        issue.setType(userType);
      }
      if (resolved != null) {
        issue.setResolved(resolved);
      }
    })).flatMap(Optional::stream).collect(Collectors.toList());
  }

  private List<TaintVulnerabilityDto> loadTaintVulnerabilities(String configurationScopeId, Binding binding, boolean shouldRefresh) {
    return branchRepository.getMatchedBranch(configurationScopeId)
      .map(matchedBranch -> {
        if (shouldRefresh) {
          synchronizationService.synchronizeTaintVulnerabilities(configurationScopeId, binding, matchedBranch);
        }
        var projectStorage = storageService.binding(binding);
        var pathTranslationOpt = pathTranslationRepository.getPathTranslation(configurationScopeId);
        if (pathTranslationOpt.isEmpty()) {
          return null;
        }
        var newCodeDefinition = projectStorage.newCodeDefinition().read().<Predicate<Instant>>map(definition -> definition::isOnNewCode).orElse(date -> true);
        return projectStorage.findings().loadTaint(matchedBranch)
          .stream().map(serverTaintIssue -> toDto(serverTaintIssue, newCodeDefinition, pathTranslationOpt.get())).collect(Collectors.toList());

      }).orElseGet(Collections::emptyList);
  }

  private static TaintVulnerabilityDto toDto(ServerTaintIssue serverTaintIssue, Predicate<Instant> isOnNewCode, FilePathTranslation translation) {
    return new TaintVulnerabilityDto(
      serverTaintIssue.getId(),
      serverTaintIssue.getSonarServerKey(),
      serverTaintIssue.isResolved(),
      serverTaintIssue.getRuleKey(),
      serverTaintIssue.getMessage(),
      translation.translate(serverTaintIssue.getFilePath()),
      serverTaintIssue.getCreationDate(),
      IssueSeverity.valueOf(serverTaintIssue.getSeverity().name()),
      RuleType.valueOf(serverTaintIssue.getType().name()),
      toDto(serverTaintIssue.getFlows(), translation),
      adapt(serverTaintIssue.getTextRange()),
      serverTaintIssue.getRuleDescriptionContextKey(),
      serverTaintIssue.getCleanCodeAttribute().map(attribute -> CleanCodeAttribute.valueOf(attribute.name())).orElse(null),
      serverTaintIssue.getImpacts().entrySet().stream().collect(
        Collectors.toMap(e -> SoftwareQuality.valueOf(e.getKey().name()), e -> org.sonarsource.sonarlint.core.rpc.protocol.common.ImpactSeverity.valueOf(e.getValue().name()))),
      isOnNewCode.test(serverTaintIssue.getCreationDate()));
  }

  public static List<TaintVulnerabilityDto.FlowDto> toDto(List<ServerTaintIssue.Flow> flows, FilePathTranslation translation) {
    return flows.stream().map(flow -> new TaintVulnerabilityDto.FlowDto(
      flow.locations().stream()
        .map(location -> {
          var filePath = location.getFilePath();
          return new TaintVulnerabilityDto.FlowDto.LocationDto(adapt(location.getTextRange()), location.getMessage(), filePath == null ? null : translation.translate(filePath));
        })
        .collect(Collectors.toList())))
      .collect(Collectors.toList());
  }

  public static TextRangeWithHashDto adapt(@Nullable TextRangeWithHash textRange) {
    return textRange == null ? null
      : new TextRangeWithHashDto(textRange.getStartLine(), textRange.getStartLineOffset(), textRange.getEndLine(), textRange.getEndLineOffset(), textRange.getHash());
  }

  private static List<ServerTaintIssue.Flow> adapt(List<TaintVulnerabilityRaisedEvent.Flow> flows) {
    return flows.stream().map(TaintVulnerabilityTrackingService::adapt).collect(Collectors.toList());
  }

  private static ServerTaintIssue.Flow adapt(TaintVulnerabilityRaisedEvent.Flow flow) {
    return new ServerTaintIssue.Flow(flow.getLocations().stream().map(TaintVulnerabilityTrackingService::adapt).collect(Collectors.toList()));
  }

  private static ServerTaintIssue.ServerIssueLocation adapt(TaintVulnerabilityRaisedEvent.Location location) {
    return new ServerTaintIssue.ServerIssueLocation(
      location.getFilePath(),
      adapt(location.getTextRange()),
      location.getMessage());
  }

  public static TextRangeWithHash adapt(TaintVulnerabilityRaisedEvent.Location.TextRange range) {
    return new TextRangeWithHash(range.getStartLine(), range.getStartLineOffset(), range.getEndLine(), range.getEndLineOffset(), range.getHash());
  }
}
