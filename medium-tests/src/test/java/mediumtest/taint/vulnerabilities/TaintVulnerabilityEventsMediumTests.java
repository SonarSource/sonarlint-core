/*
 * SonarLint Core - Medium Tests
 * Copyright (C) 2016-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package mediumtest.taint.vulnerabilities;

import java.nio.file.Paths;
import java.time.Duration;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.List;
import java.util.Set;
import java.util.UUID;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.api.extension.RegisterExtension;
import org.sonarsource.sonarlint.core.commons.IssueSeverity;
import org.sonarsource.sonarlint.core.commons.LogTestStartAndEnd;
import org.sonarsource.sonarlint.core.commons.RuleType;
import org.sonarsource.sonarlint.core.commons.log.SonarLintLogTester;
import org.sonarsource.sonarlint.core.rpc.protocol.backend.initialize.BackendCapability;
import org.sonarsource.sonarlint.core.rpc.protocol.backend.issue.ChangeIssueStatusParams;
import org.sonarsource.sonarlint.core.rpc.protocol.backend.issue.ResolutionStatus;
import org.sonarsource.sonarlint.core.rpc.protocol.backend.rules.ImpactDto;
import org.sonarsource.sonarlint.core.rpc.protocol.backend.tracking.TaintVulnerabilityDto;
import org.sonarsource.sonarlint.core.rpc.protocol.backend.tracking.TextRangeWithHashDto;
import org.sonarsource.sonarlint.core.rpc.protocol.client.taint.vulnerability.DidChangeTaintVulnerabilitiesParams;
import org.sonarsource.sonarlint.core.rpc.protocol.common.CleanCodeAttribute;
import org.sonarsource.sonarlint.core.rpc.protocol.common.Either;
import org.sonarsource.sonarlint.core.rpc.protocol.common.ImpactSeverity;
import org.sonarsource.sonarlint.core.rpc.protocol.common.MQRModeDetails;
import org.sonarsource.sonarlint.core.rpc.protocol.common.SoftwareQuality;
import org.sonarsource.sonarlint.core.rpc.protocol.common.StandardModeDetails;
import org.sonarsource.sonarlint.core.serverconnection.issues.ServerTaintIssue;
import org.sonarsource.sonarlint.core.test.utils.SonarLintTestRpcServer;
import org.sonarsource.sonarlint.core.test.utils.junit5.SonarLintTest;
import org.sonarsource.sonarlint.core.test.utils.junit5.SonarLintTestHarness;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.tuple;
import static org.awaitility.Awaitility.await;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.when;
import static org.sonarsource.sonarlint.core.rpc.protocol.common.Language.JAVA;
import static org.sonarsource.sonarlint.core.test.utils.storage.ServerTaintIssueFixtures.aServerTaintIssue;

@ExtendWith(LogTestStartAndEnd.class)
class TaintVulnerabilityEventsMediumTests {

  @RegisterExtension
  static SonarLintLogTester logTester = new SonarLintLogTester();

  @Nested
  class WhenReceivingTaintRaisedEvent {
    private final String eventPayload = """
      event: TaintVulnerabilityRaised
      data: {\
          "key": "taintKey",\
          "projectKey": "projectKey",\
          "branch": "branchName",\
          "creationDate": 123456789,\
          "ruleKey": "javasecurity:S123",\
          "severity": "MAJOR",\
          "type": "VULNERABILITY",\
          "mainLocation": {\
            "filePath": "functions/taint.js",\
            "message": "blah blah",\
            "textRange": {\
              "startLine": 17,\
              "startLineOffset": 10,\
              "endLine": 3,\
              "endLineOffset": 2,\
              "hash": "hash"\
            }\
          },\
          "flows": [\
            {\
              "locations": [\
                {\
                  "filePath": "functions/taint.js",\
                  "message": "sink: tainted value is used to perform a security-sensitive operation",\
                  "textRange": {\
                    "startLine": 17,\
                    "startLineOffset": 10,\
                    "endLine": 3,\
                    "endLineOffset": 2,\
                    "hash": "hash1"\
                  }\
                },\
                {\
                  "filePath": "functions/taint2.js",\
                  "message": "sink: tainted value is used to perform a security-sensitive operation",\
                  "textRange": {\
                    "startLine": 18,\
                    "startLineOffset": 11,\
                    "endLine": 4,\
                    "endLineOffset": 3,\
                    "hash": "hash2"\
                  }\
                }\
              ]\
            }\
          ]\
      }

      """;

    @SonarLintTest
    void it_should_store_taint_vulnerability_in_storage(SonarLintTestHarness harness) {
      var server = harness.newFakeSonarQubeServer("10.0")
        .withServerSentEventsEnabled()
        .withProject("projectKey",
          project -> project.withBranch("branchName"))
        .start();
      var client = harness.newFakeClient().build();
      when(client.matchSonarProjectBranch(eq("configScope"), any(), any(), any())).thenReturn("branchName");
      var backend = harness.newBackend()
        .withExtraEnabledLanguagesInConnectedMode(JAVA)
        .withBackendCapability(BackendCapability.SERVER_SENT_EVENTS)
        .withSonarQubeConnection("connectionId", server)
        .withBoundConfigScope("configScope", "connectionId", "projectKey")
        .start(client);

      server.pushEvent(eventPayload);

      await().atMost(Duration.ofSeconds(2)).untilAsserted(() -> assertThat(readTaintVulnerabilities(backend, "connectionId", "projectKey", "branchName"))
        .extracting(ServerTaintIssue::getSonarServerKey)
        .containsOnly("taintKey"));
    }

    @SonarLintTest
    void it_should_notify_client(SonarLintTestHarness harness) {
      var server = harness.newFakeSonarQubeServer("10.0")
        .withServerSentEventsEnabled()
        .withProject("projectKey",
          project -> project.withBranch("branchName"))
        .start();
      var client = harness.newFakeClient().build();
      when(client.matchSonarProjectBranch(eq("configScope"), any(), any(), any())).thenReturn("branchName");
      harness.newBackend()
        .withExtraEnabledLanguagesInConnectedMode(JAVA)
        .withBackendCapability(BackendCapability.SERVER_SENT_EVENTS, BackendCapability.FULL_SYNCHRONIZATION)
        .withSonarQubeConnection("connectionId", server)
        .withBoundConfigScope("configScope", "connectionId", "projectKey")
        .start(client);
      // Wait for synchronization so that the local storage has the correct severity mode
      client.waitForSynchronization();

      server.pushEvent(eventPayload);

      await().atMost(Duration.ofSeconds(2)).untilAsserted(() -> assertThat(client.getTaintVulnerabilityChanges())
        .usingRecursiveComparison()
        .ignoringFields("addedTaintVulnerabilities.id")
        .isEqualTo(List.of(new DidChangeTaintVulnerabilitiesParams("configScope", Set.of(),
          List
            .of(new TaintVulnerabilityDto(UUID.randomUUID(), "taintKey", false, "javasecurity:S123", "blah blah", Paths.get("functions/taint.js"), Instant.ofEpochMilli(123456789),
              Either.forLeft(new StandardModeDetails(org.sonarsource.sonarlint.core.rpc.protocol.common.IssueSeverity.MAJOR,
                org.sonarsource.sonarlint.core.rpc.protocol.common.RuleType.VULNERABILITY)),
              List.of(new TaintVulnerabilityDto.FlowDto(List.of(
                new TaintVulnerabilityDto.FlowDto.LocationDto(new TextRangeWithHashDto(17, 10, 3, 2, "hash1"),
                  "sink: tainted value is used to perform a security-sensitive operation",
                  Paths.get("functions/taint.js")),
                new TaintVulnerabilityDto.FlowDto.LocationDto(new TextRangeWithHashDto(18, 11, 4, 3, "hash2"),
                  "sink: tainted value is used to perform a security-sensitive operation", Paths.get("functions/taint2.js"))))),
              new TextRangeWithHashDto(17, 10, 3, 2, "hash"), null, true, false)),
          List.of()))));
    }
  }

  @Nested
  class WhenReceivingIssueChangedEvent {
    @SonarLintTest
    void it_should_update_taint_vulnerability_in_storage_with_new_resolution(SonarLintTestHarness harness) {
      var server = harness.newFakeSonarQubeServer("10.0")
        .withServerSentEventsEnabled()
        .withProject("projectKey",
          project -> project.withBranch("branchName"))
        .start();
      var client = harness.newFakeClient().build();
      when(client.matchSonarProjectBranch(eq("configScope"), any(), any(), any())).thenReturn("branchName");
      var backend = harness.newBackend()
        .withExtraEnabledLanguagesInConnectedMode(JAVA)
        .withBackendCapability(BackendCapability.SERVER_SENT_EVENTS)
        .withSonarQubeConnection("connectionId", server,
          storage -> storage.withProject("projectKey", project -> project.withMainBranch("branchName", branch -> branch.withTaintIssue(aServerTaintIssue("key1").open()))))
        .withBoundConfigScope("configScope", "connectionId", "projectKey")
        .start(client);

      server.pushEvent("""
        event: IssueChanged
        data: {\
          "projectKey": "projectKey",\
          "issues": [{\
            "issueKey": "key1",\
            "branchName": "branchName"\
          }],\
          "resolved": true\
        }

        """);

      await().atMost(Duration.ofSeconds(2)).untilAsserted(() -> assertThat(readTaintVulnerabilities(backend, "connectionId", "projectKey", "branchName"))
        .extracting(ServerTaintIssue::getSonarServerKey, ServerTaintIssue::isResolved)
        .containsOnly(tuple("key1", true)));
    }

    @SonarLintTest
    void it_should_update_taint_vulnerability_in_storage_with_new_severity(SonarLintTestHarness harness) {
      var server = harness.newFakeSonarQubeServer("10.0")
        .withServerSentEventsEnabled()
        .withProject("projectKey",
          project -> project.withBranch("branchName"))
        .start();
      var client = harness.newFakeClient().build();
      when(client.matchSonarProjectBranch(eq("configScope"), any(), any(), any())).thenReturn("branchName");
      var backend = harness.newBackend()
        .withExtraEnabledLanguagesInConnectedMode(JAVA)
        .withBackendCapability(BackendCapability.SERVER_SENT_EVENTS)
        .withSonarQubeConnection("connectionId", server,
          storage -> storage.withProject("projectKey",
            project -> project.withMainBranch("branchName", branch -> branch.withTaintIssue(aServerTaintIssue("key1").withSeverity(IssueSeverity.INFO)))))
        .withBoundConfigScope("configScope", "connectionId", "projectKey")
        .start(client);

      server.pushEvent("""
        event: IssueChanged
        data: {\
          "projectKey": "projectKey",\
          "issues": [{\
            "issueKey": "key1",\
            "branchName": "branchName"\
          }],\
          "userSeverity": "CRITICAL"\
        }

        """);

      await().atMost(Duration.ofSeconds(2)).untilAsserted(() -> assertThat(readTaintVulnerabilities(backend, "connectionId", "projectKey", "branchName"))
        .extracting(ServerTaintIssue::getSonarServerKey, ServerTaintIssue::getSeverity)
        .containsOnly(tuple("key1", IssueSeverity.CRITICAL)));
    }

    @SonarLintTest
    void it_should_update_taint_vulnerability_in_storage_with_new_type(SonarLintTestHarness harness) {
      var server = harness.newFakeSonarQubeServer("10.0")
        .withServerSentEventsEnabled()
        .withProject("projectKey",
          project -> project.withBranch("branchName"))
        .start();
      var client = harness.newFakeClient().build();
      when(client.matchSonarProjectBranch(eq("configScope"), any(), any(), any())).thenReturn("branchName");
      var backend = harness.newBackend()
        .withExtraEnabledLanguagesInConnectedMode(JAVA)
        .withBackendCapability(BackendCapability.SERVER_SENT_EVENTS)
        .withSonarQubeConnection("connectionId", server,
          storage -> storage.withProject("projectKey",
            project -> project.withMainBranch("branchName", branch -> branch.withTaintIssue(aServerTaintIssue("key1").withType(RuleType.VULNERABILITY)))))
        .withBoundConfigScope("configScope", "connectionId", "projectKey")
        .start(client);

      server.pushEvent("""
        event: IssueChanged
        data: {\
          "projectKey": "projectKey",\
          "issues": [{\
            "issueKey": "key1",\
            "branchName": "branchName"\
          }],\
          "userType": "BUG"\
        }

        """);

      await().atMost(Duration.ofSeconds(2)).untilAsserted(() -> assertThat(readTaintVulnerabilities(backend, "connectionId", "projectKey", "branchName"))
        .extracting(ServerTaintIssue::getSonarServerKey, ServerTaintIssue::getType)
        .containsOnly(tuple("key1", RuleType.BUG)));
    }

    @SonarLintTest
    void it_should_notify_client(SonarLintTestHarness harness) {
      var server = harness.newFakeSonarQubeServer("10.0")
        .withServerSentEventsEnabled()
        .withProject("projectKey",
          project -> project.withBranch("branchName"))
        .start();
      var client = harness.newFakeClient().build();
      when(client.matchSonarProjectBranch(eq("configScope"), any(), any(), any())).thenReturn("branchName");
      var introductionDate = Instant.now().truncatedTo(ChronoUnit.SECONDS);
      var backend = harness.newBackend()
        .withExtraEnabledLanguagesInConnectedMode(JAVA)
        .withBackendCapability(BackendCapability.SERVER_SENT_EVENTS, BackendCapability.FULL_SYNCHRONIZATION)
        .withSonarQubeConnection("connectionId", server,
          storage -> storage.withProject("projectKey",
            project -> project.withMainBranch("branchName",
              branch -> branch.withTaintIssue(aServerTaintIssue("key1").withIntroductionDate(introductionDate).withSeverity(IssueSeverity.MINOR)))))
        .withBoundConfigScope("configScope", "connectionId", "projectKey")
        .start(client);
      // Wait for synchronization so that the local storage has the correct severity mode
      client.waitForSynchronization();
      var storedTaintIssues = await().atMost(Duration.ofSeconds(2)).until(() -> readTaintVulnerabilities(backend, "connectionId", "projectKey", "branchName"),
        taints -> taints.size() == 1);

      server.pushEvent("""
        event: IssueChanged
        data: {\
          "projectKey": "projectKey",\
          "issues": [{\
            "issueKey": "key1",\
            "branchName": "branchName"\
          }],\
          "userSeverity": "CRITICAL"\
        }

        """);

      await().atMost(Duration.ofSeconds(2)).untilAsserted(() -> assertThat(client.getTaintVulnerabilityChanges())
        .usingRecursiveComparison()
        .isEqualTo(List.of(new DidChangeTaintVulnerabilitiesParams("configScope", Set.of(), List.of(),
          List.of(new TaintVulnerabilityDto(storedTaintIssues.get(0).getId(), "key1", false, "ruleKey", "message", Paths.get("file/path"), introductionDate,
            Either.forLeft(
              new StandardModeDetails(org.sonarsource.sonarlint.core.rpc.protocol.common.IssueSeverity.CRITICAL, org.sonarsource.sonarlint.core.rpc.protocol.common.RuleType.BUG)),
            List.of(), new TextRangeWithHashDto(1, 2, 3, 4, "rangeHash"), "contextKey",
            true, false))))));
    }
  }

  @Nested
  class WhenReceivingTaintClosedEvent {
    @SonarLintTest
    void it_should_remove_taint_vulnerability_from_storage(SonarLintTestHarness harness) {
      var server = harness.newFakeSonarQubeServer("10.0")
        .withServerSentEventsEnabled()
        .withProject("projectKey",
          project -> project.withBranch("branchName"))
        .start();
      var client = harness.newFakeClient().build();
      when(client.matchSonarProjectBranch(eq("configScope"), any(), any(), any())).thenReturn("branchName");
      var backend = harness.newBackend()
        .withExtraEnabledLanguagesInConnectedMode(JAVA)
        .withBackendCapability(BackendCapability.SERVER_SENT_EVENTS)
        .withSonarQubeConnection("connectionId", server,
          storage -> storage.withProject("projectKey",
            project -> project.withMainBranch("branchName", branch -> branch.withTaintIssue(aServerTaintIssue("key1").withType(RuleType.VULNERABILITY)))))
        .withBoundConfigScope("configScope", "connectionId", "projectKey")
        .start(client);

      server.pushEvent("""
        event: TaintVulnerabilityClosed
        data: {\
          "projectKey": "projectKey",\
          "key": "key1"\
        }

        """);

      await().atMost(Duration.ofSeconds(2)).untilAsserted(() -> assertThat(readTaintVulnerabilities(backend, "connectionId", "projectKey", "branchName"))
        .isEmpty());
    }

    @SonarLintTest
    void it_should_notify_client(SonarLintTestHarness harness) {
      var server = harness.newFakeSonarQubeServer("10.0")
        .withServerSentEventsEnabled()
        .withProject("projectKey",
          project -> project.withBranch("branchName"))
        .start();
      var client = harness.newFakeClient().build();
      when(client.matchSonarProjectBranch(eq("configScope"), any(), any(), any())).thenReturn("branchName");
      var backend = harness.newBackend()
        .withExtraEnabledLanguagesInConnectedMode(JAVA)
        .withBackendCapability(BackendCapability.SERVER_SENT_EVENTS)
        .withSonarQubeConnection("connectionId", server,
          storage -> storage.withProject("projectKey",
            project -> project.withMainBranch("branchName", branch -> branch.withTaintIssue(aServerTaintIssue("key1").withType(RuleType.VULNERABILITY)))))
        .withBoundConfigScope("configScope", "connectionId", "projectKey")
        .start(client);
      var storedTaintIssues = await().atMost(Duration.ofSeconds(2)).until(() -> readTaintVulnerabilities(backend, "connectionId", "projectKey", "branchName"),
        taints -> taints.size() == 1);

      server.pushEvent("""
        event: TaintVulnerabilityClosed
        data: {\
          "projectKey": "projectKey",\
          "key": "key1"\
        }

        """);

      await().atMost(Duration.ofSeconds(2)).untilAsserted(() -> assertThat(client.getTaintVulnerabilityChanges())
        .usingRecursiveComparison()
        .isEqualTo(List.of(new DidChangeTaintVulnerabilitiesParams("configScope", Set.of(storedTaintIssues.get(0).getId()), List.of(), List.of()))));
    }
  }

  @Nested
  class WhenChangingIssueStatus {
    @SonarLintTest
    void it_should_notify_client(SonarLintTestHarness harness) {
      var server = harness.newFakeSonarQubeServer("10.0")
        .withServerSentEventsEnabled()
        .withProject("projectKey",
          project -> project.withBranch("branchName"))
        .start();
      var client = harness.newFakeClient().build();
      when(client.matchSonarProjectBranch(eq("configScope"), any(), any(), any())).thenReturn("branchName");
      var introductionDate = Instant.now().truncatedTo(ChronoUnit.SECONDS);
      var backend = harness.newBackend()
        .withExtraEnabledLanguagesInConnectedMode(JAVA)
        .withSonarQubeConnection("connectionId", server,
          storage -> storage.withProject("projectKey",
            project -> project.withMainBranch("branchName",
              branch -> branch.withTaintIssue(aServerTaintIssue("key1").withIntroductionDate(introductionDate).withType(RuleType.VULNERABILITY)))))
        .withBoundConfigScope("configScope", "connectionId", "projectKey")
        .withBackendCapability(BackendCapability.FULL_SYNCHRONIZATION)
        .start(client);
      // Wait for synchronization so that the local storage has the correct severity mode
      client.waitForSynchronization();
      var storedTaintIssues = await().atMost(Duration.ofSeconds(2)).until(() -> readTaintVulnerabilities(backend, "connectionId", "projectKey", "branchName"),
        taints -> taints.size() == 1);

      backend.getIssueService().changeStatus(new ChangeIssueStatusParams("configScope", "key1", ResolutionStatus.WONT_FIX, true));

      await().atMost(Duration.ofSeconds(5)).untilAsserted(() -> assertThat(client.getTaintVulnerabilityChanges())
        .usingRecursiveFieldByFieldElementComparatorIgnoringFields("addedTaintVulnerabilities.id")
        .contains(new DidChangeTaintVulnerabilitiesParams("configScope", Set.of(), List.of(),
          List.of(new TaintVulnerabilityDto(storedTaintIssues.get(0).getId(), "key1", true, "ruleKey", "message", Paths.get("file/path"), introductionDate,
            Either.forLeft(new StandardModeDetails(org.sonarsource.sonarlint.core.rpc.protocol.common.IssueSeverity.MINOR,
              org.sonarsource.sonarlint.core.rpc.protocol.common.RuleType.VULNERABILITY)),
            List.of(),
            new TextRangeWithHashDto(1, 2, 3, 4, "rangeHash"), "contextKey", true, false)))));
    }

    @SonarLintTest
    void it_should_notify_client_with_correct_mqr_severity_mode(SonarLintTestHarness harness) {
      var server = harness.newFakeSonarQubeServer("10.5")
        .withServerSentEventsEnabled()
        .withProject("projectKey",
          project -> project.withBranch("branchName"))
        .start();
      var client = harness.newFakeClient().build();
      when(client.matchSonarProjectBranch(eq("configScope"), any(), any(), any())).thenReturn("branchName");
      var introductionDate = Instant.now().truncatedTo(ChronoUnit.SECONDS);
      var backend = harness.newBackend()
        .withExtraEnabledLanguagesInConnectedMode(JAVA)
        .withSonarQubeConnection("connectionId", server,
          storage -> storage.withProject("projectKey",
            project -> project.withMainBranch("branchName",
              branch -> branch.withTaintIssue(aServerTaintIssue("key1").withIntroductionDate(introductionDate).withType(RuleType.VULNERABILITY)))))
        .withBoundConfigScope("configScope", "connectionId", "projectKey")
        .withBackendCapability(BackendCapability.FULL_SYNCHRONIZATION)
        .start(client);
      // Wait for synchronization so that the local storage has the correct severity mode
      client.waitForSynchronization();
      var storedTaintIssues = await().atMost(Duration.ofSeconds(2)).until(() -> readTaintVulnerabilities(backend, "connectionId", "projectKey", "branchName"),
        taints -> taints.size() == 1);

      backend.getIssueService().changeStatus(new ChangeIssueStatusParams("configScope", "key1", ResolutionStatus.WONT_FIX, true));

      await().atMost(Duration.ofSeconds(2)).untilAsserted(() -> assertThat(client.getTaintVulnerabilityChanges())
        .usingRecursiveFieldByFieldElementComparatorIgnoringFields("addedTaintVulnerabilities.id")
        .contains(new DidChangeTaintVulnerabilitiesParams("configScope", Set.of(), List.of(),
          List.of(new TaintVulnerabilityDto(storedTaintIssues.get(0).getId(), "key1", true, "ruleKey", "message", Paths.get("file/path"), introductionDate,
            Either.forRight(new MQRModeDetails(CleanCodeAttribute.CONVENTIONAL, List.of(new ImpactDto(SoftwareQuality.MAINTAINABILITY, ImpactSeverity.MEDIUM)))), List.of(),
            new TextRangeWithHashDto(1, 2, 3, 4, "rangeHash"), "contextKey", true, false)))));
    }
  }

  private List<ServerTaintIssue> readTaintVulnerabilities(SonarLintTestRpcServer backend, String connectionId, String projectKey, String branchName) {
    return backend.getIssueStorageService().connection(connectionId).project(projectKey).findings().loadTaint(branchName);
  }
}
