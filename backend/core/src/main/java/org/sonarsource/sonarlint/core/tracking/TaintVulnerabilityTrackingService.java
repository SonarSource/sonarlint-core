/*
 * SonarLint Core - Implementation
 * Copyright (C) 2016-2025 SonarSource SÃ rl
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonarsource.sonarlint.core.tracking;

import java.time.Instant;
import java.util.Collections;
import java.util.EnumMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.function.Predicate;
import javax.annotation.Nullable;
import org.sonarsource.sonarlint.core.branch.SonarProjectBranchTrackingService;
import org.sonarsource.sonarlint.core.commons.Binding;
import org.sonarsource.sonarlint.core.commons.ImpactSeverity;
import org.sonarsource.sonarlint.core.commons.api.TextRangeWithHash;
import org.sonarsource.sonarlint.core.commons.progress.SonarLintCancelMonitor;
import org.sonarsource.sonarlint.core.event.ServerIssueStatusChangedEvent;
import org.sonarsource.sonarlint.core.event.SonarServerEventReceivedEvent;
import org.sonarsource.sonarlint.core.event.TaintVulnerabilitiesSynchronizedEvent;
import org.sonarsource.sonarlint.core.file.FilePathTranslation;
import org.sonarsource.sonarlint.core.file.PathTranslationService;
import org.sonarsource.sonarlint.core.mode.SeverityModeService;
import org.sonarsource.sonarlint.core.remediation.aicodefix.AiCodeFixFeature;
import org.sonarsource.sonarlint.core.remediation.aicodefix.AiCodeFixService;
import org.sonarsource.sonarlint.core.repository.config.ConfigurationRepository;
import org.sonarsource.sonarlint.core.rpc.protocol.SonarLintRpcClient;
import org.sonarsource.sonarlint.core.rpc.protocol.backend.rules.ImpactDto;
import org.sonarsource.sonarlint.core.rpc.protocol.backend.tracking.TaintVulnerabilityDto;
import org.sonarsource.sonarlint.core.rpc.protocol.client.taint.vulnerability.DidChangeTaintVulnerabilitiesParams;
import org.sonarsource.sonarlint.core.rpc.protocol.common.CleanCodeAttribute;
import org.sonarsource.sonarlint.core.rpc.protocol.common.Either;
import org.sonarsource.sonarlint.core.rpc.protocol.common.IssueSeverity;
import org.sonarsource.sonarlint.core.rpc.protocol.common.MQRModeDetails;
import org.sonarsource.sonarlint.core.rpc.protocol.common.RuleType;
import org.sonarsource.sonarlint.core.rpc.protocol.common.SoftwareQuality;
import org.sonarsource.sonarlint.core.rpc.protocol.common.StandardModeDetails;
import org.sonarsource.sonarlint.core.serverapi.push.IssueChangedEvent;
import org.sonarsource.sonarlint.core.serverapi.push.TaintVulnerabilityClosedEvent;
import org.sonarsource.sonarlint.core.serverapi.push.TaintVulnerabilityRaisedEvent;
import org.sonarsource.sonarlint.core.serverconnection.aicodefix.AiCodeFixRepository;
import org.sonarsource.sonarlint.core.serverconnection.issues.ServerTaintIssue;
import org.sonarsource.sonarlint.core.storage.StorageService;
import org.sonarsource.sonarlint.core.sync.TaintSynchronizationService;
import org.springframework.context.event.EventListener;

import static java.util.Collections.emptyList;
import static java.util.Collections.emptySet;

public class TaintVulnerabilityTrackingService {
  private final SonarLintRpcClient client;
  private final ConfigurationRepository configurationRepository;
  private final SonarProjectBranchTrackingService branchTrackingService;
  private final TaintSynchronizationService taintSynchronizationService;
  private final StorageService storageService;
  private final PathTranslationService pathTranslationService;
  private final SeverityModeService severityModeService;
  private final AiCodeFixRepository aiCodeFixRepository;

  public TaintVulnerabilityTrackingService(SonarLintRpcClient client, ConfigurationRepository configurationRepository, SonarProjectBranchTrackingService branchTrackingService,
    TaintSynchronizationService taintSynchronizationService, StorageService storageService, PathTranslationService pathTranslationService, SeverityModeService severityModeService,
    AiCodeFixRepository aiCodeFixRepository) {
    this.client = client;
    this.configurationRepository = configurationRepository;
    this.branchTrackingService = branchTrackingService;
    this.taintSynchronizationService = taintSynchronizationService;
    this.storageService = storageService;
    this.pathTranslationService = pathTranslationService;
    this.severityModeService = severityModeService;
    this.aiCodeFixRepository = aiCodeFixRepository;
  }

  public List<TaintVulnerabilityDto> listAll(String configurationScopeId, boolean shouldRefresh, SonarLintCancelMonitor cancelMonitor) {
    return configurationRepository.getEffectiveBinding(configurationScopeId)
      .map(binding -> loadTaintVulnerabilities(configurationScopeId, binding, shouldRefresh, cancelMonitor))
      .orElseGet(Collections::emptyList);
  }

  @EventListener
  public void onServerEventReceived(SonarServerEventReceivedEvent eventReceived) {
    var connectionId = eventReceived.getConnectionId();
    var serverEvent = eventReceived.getEvent();
    if (serverEvent instanceof TaintVulnerabilityRaisedEvent raisedEvent) {
      insertIntoStorageAndNotifyClient(connectionId, raisedEvent);
    } else if (serverEvent instanceof TaintVulnerabilityClosedEvent closedEvent) {
      removeFromStorageAndNotifyClient(connectionId, closedEvent);
    } else if ((serverEvent instanceof IssueChangedEvent changedEvent)) {
      updateStorageAndNotifyClient(connectionId, changedEvent);
    }
  }

  @EventListener
  public void onServerIssueStatusChanged(ServerIssueStatusChangedEvent event) {
    var finding = event.getFinding();
    if (finding instanceof ServerTaintIssue taintVulnerability) {
      var connectionId = event.getConnectionId();
      var projectKey = event.getProjectKey();
      var isMQRMode = severityModeService.isMQRModeForConnection(event.getConnectionId());
      var isAiCodeFixable = isAiCodeFixable(taintVulnerability, new Binding(connectionId, projectKey));
      configurationRepository.getBoundScopesToConnectionAndSonarProject(connectionId, projectKey)
        .forEach(boundScope -> {
          var newCodeDefinition = storageService.connection(connectionId).project(projectKey).newCodeDefinition().read()
            .<Predicate<Instant>>map(definition -> definition::isOnNewCode).orElse(date -> true);
          var pathTranslation = pathTranslationService.getOrComputePathTranslation(boundScope.getConfigScopeId());
          pathTranslation.ifPresent(translation -> client.didChangeTaintVulnerabilities(
            new DidChangeTaintVulnerabilitiesParams(boundScope.getConfigScopeId(), emptySet(), emptyList(),
              List.of(toDto(taintVulnerability, newCodeDefinition, translation, isMQRMode, isAiCodeFixable)))));
        });
    }
  }

  @EventListener
  public void onTaintVulnerabilitiesSynchronized(TaintVulnerabilitiesSynchronizedEvent event) {
    var summary = event.getSummary();
    var connectionId = event.getConnectionId();
    var sonarProjectKey = event.getSonarProjectKey();
    var newCodeDefinition = storageService.connection(connectionId).project(sonarProjectKey).newCodeDefinition().read()
      .<Predicate<Instant>>map(definition -> definition::isOnNewCode).orElse(date -> true);
    var isMQRMode = severityModeService.isMQRModeForConnection(event.getConnectionId());
    configurationRepository.getBoundScopesToConnectionAndSonarProject(connectionId, sonarProjectKey).forEach(boundScope -> {
      var pathTranslation = pathTranslationService.getOrComputePathTranslation(boundScope.getConfigScopeId());
      pathTranslation
        .ifPresent(
          translation -> client.didChangeTaintVulnerabilities(new DidChangeTaintVulnerabilitiesParams(boundScope.getConfigScopeId(), summary.deletedItemIds(),
            summary.addedItems().stream()
              .map(taint -> {
                var isAiCodeFixable = isAiCodeFixable(taint, new Binding(connectionId, sonarProjectKey));
                return toDto(taint, newCodeDefinition, translation, isMQRMode, isAiCodeFixable);
              })
              .toList(),
            summary.updatedItems().stream()
              .map(taint -> {
                var isAiCodeFixable = isAiCodeFixable(taint, new Binding(connectionId, sonarProjectKey));
                return toDto(taint, newCodeDefinition, translation, isMQRMode, isAiCodeFixable);
              })
              .toList())));
    });
  }

  private void insertIntoStorageAndNotifyClient(String connectionId, TaintVulnerabilityRaisedEvent event) {
    var newTaintVulnerability = new ServerTaintIssue(
      UUID.randomUUID(),
      event.getKey(),
      false,
      null,
      event.getRuleKey(),
      event.getMainLocation().getMessage(),
      event.getMainLocation().getFilePath(),
      event.getCreationDate(),
      event.getSeverity(),
      event.getType(),
      adapt(event.getMainLocation().getTextRange()),
      event.getRuleDescriptionContextKey(),
      event.getCleanCodeAttribute().orElse(null),
      event.getImpacts(),
      adapt(event.getFlows()));
    var projectKey = event.getProjectKey();
    var binding = new Binding(connectionId, projectKey);
    storageService.binding(binding).findings().insert(event.getBranchName(), newTaintVulnerability);
    var isMQRMode = severityModeService.isMQRModeForConnection(connectionId);
    var isAiCodeFixable = isAiCodeFixable(newTaintVulnerability, binding);
    configurationRepository.getBoundScopesToConnectionAndSonarProject(connectionId, projectKey).forEach(boundScope -> {
      var pathTranslation = pathTranslationService.getOrComputePathTranslation(boundScope.getConfigScopeId());
      pathTranslation.ifPresent(translation -> client.didChangeTaintVulnerabilities(
        new DidChangeTaintVulnerabilitiesParams(boundScope.getConfigScopeId(), emptySet(),
          List.of(toDto(newTaintVulnerability, date -> true, translation, isMQRMode, isAiCodeFixable)),
          emptyList())));
    });
  }

  private void removeFromStorageAndNotifyClient(String connectionId, TaintVulnerabilityClosedEvent event) {
    var projectKey = event.getProjectKey();
    storageService.connection(connectionId)
      .project(projectKey)
      .findings()
      .deleteTaintIssueBySonarServerKey(event.getTaintIssueKey())
      .ifPresent(deletedId -> configurationRepository.getBoundScopesToConnectionAndSonarProject(connectionId, projectKey).forEach(boundScope -> client
        .didChangeTaintVulnerabilities(new DidChangeTaintVulnerabilitiesParams(boundScope.getConfigScopeId(), Set.of(deletedId), emptyList(), emptyList()))));
  }

  private void updateStorageAndNotifyClient(String connectionId, IssueChangedEvent event) {
    var projectKey = event.getProjectKey();
    var updatedTaintVulnerabilities = updateTaintIssues(connectionId, projectKey, event.getUserSeverity(), event.getUserType(), event.getResolved(), event.getImpactedIssues());
    if (!updatedTaintVulnerabilities.isEmpty()) {
      configurationRepository.getBoundScopesToConnectionAndSonarProject(connectionId, projectKey).forEach(boundScope -> {
        var newCodeDefinition = storageService.connection(connectionId).project(projectKey).newCodeDefinition().read()
          .<Predicate<Instant>>map(definition -> definition::isOnNewCode).orElse(date -> true);
        var isMQRMode = severityModeService.isMQRModeForConnection(connectionId);
        pathTranslationService.getOrComputePathTranslation(boundScope.getConfigScopeId())
          .ifPresent(translation -> client.didChangeTaintVulnerabilities(new DidChangeTaintVulnerabilitiesParams(boundScope.getConfigScopeId(), emptySet(),
            emptyList(),
            updatedTaintVulnerabilities.stream()
              .map(taintIssue -> {
                var isAiCodeFixable = isAiCodeFixable(taintIssue, boundScope.getBinding());
                return toDto(taintIssue, newCodeDefinition, translation, isMQRMode, isAiCodeFixable);
              })
              .toList())));
      });
    }
  }

  private List<ServerTaintIssue> updateTaintIssues(String connectionId, String projectKey, @Nullable org.sonarsource.sonarlint.core.commons.IssueSeverity userSeverity,
    @Nullable org.sonarsource.sonarlint.core.commons.RuleType userType, @Nullable Boolean resolved, List<IssueChangedEvent.Issue> issues) {
    var findingsStorage = storageService.connection(connectionId).project(projectKey).findings();
    return issues.stream().map(issueEvent -> findingsStorage.updateTaintIssueBySonarServerKey(issueEvent.getIssueKey(), issue -> {
      if (userSeverity != null) {
        issue.setSeverity(userSeverity);
      }
      if (userType != null) {
        issue.setType(userType);
      }
      if (resolved != null) {
        issue.setResolved(resolved);
      }
      var impacts = issueEvent.getImpacts();
      if (!impacts.isEmpty()) {
        issue.setImpacts(mergeImpacts(issue.getImpacts(), impacts));
      }
    })).flatMap(Optional::stream).toList();
  }

  private static Map<org.sonarsource.sonarlint.core.commons.SoftwareQuality, ImpactSeverity> mergeImpacts(
    Map<org.sonarsource.sonarlint.core.commons.SoftwareQuality, ImpactSeverity> defaultImpacts,
    Map<org.sonarsource.sonarlint.core.commons.SoftwareQuality, ImpactSeverity> overriddenImpacts) {
    var mergedImpacts = new EnumMap<org.sonarsource.sonarlint.core.commons.SoftwareQuality, ImpactSeverity>(org.sonarsource.sonarlint.core.commons.SoftwareQuality.class);
    if (!defaultImpacts.isEmpty()) {
      mergedImpacts = new EnumMap<>(defaultImpacts);
    }

    for (var entry : overriddenImpacts.entrySet()) {
      var quality = org.sonarsource.sonarlint.core.commons.SoftwareQuality.valueOf(entry.getKey().name());
      var severity = ImpactSeverity.mapSeverity(entry.getValue().name());
      mergedImpacts.put(quality, severity);
    }

    return Collections.unmodifiableMap(mergedImpacts);
  }

  private List<TaintVulnerabilityDto> loadTaintVulnerabilities(String configurationScopeId, Binding binding, boolean shouldRefresh, SonarLintCancelMonitor cancelMonitor) {
    var matchedBranchOpt = branchTrackingService.awaitEffectiveSonarProjectBranch(configurationScopeId);
    var pathTranslationOpt = pathTranslationService.getOrComputePathTranslation(configurationScopeId);
    if (matchedBranchOpt.isPresent() && pathTranslationOpt.isPresent()) {
      if (shouldRefresh) {
        taintSynchronizationService.synchronizeTaintVulnerabilities(binding.connectionId(), binding.sonarProjectKey(), cancelMonitor);
      }
      var projectStorage = storageService.binding(binding);
      var newCodeDefinition = projectStorage.newCodeDefinition().read().<Predicate<Instant>>map(definition -> definition::isOnNewCode).orElse(date -> true);
      var isMQRMode = severityModeService.isMQRModeForConnection(binding.connectionId());
      var translation = pathTranslationOpt.get();
      String matchedBranch = matchedBranchOpt.get();
      return projectStorage.findings().loadTaint(matchedBranch)
        .stream().map(serverTaintIssue -> {
          var isAiCodeFixable = isAiCodeFixable(serverTaintIssue, binding);
          return toDto(serverTaintIssue, newCodeDefinition, translation, isMQRMode, isAiCodeFixable);
        })
        .toList();
    } else {
      return Collections.emptyList();
    }
  }

  public Optional<TaintVulnerabilityDto> getTaintVulnerability(String configurationScopeId, UUID issueId, SonarLintCancelMonitor cancelMonitor) {
    var maybeBinding = configurationRepository.getEffectiveBinding(configurationScopeId);
    return maybeBinding.flatMap(binding -> loadTaintVulnerabilities(configurationScopeId, binding, false, cancelMonitor)
      .stream()
      .filter(taintVulnerabilityDto -> taintVulnerabilityDto.getId().equals(issueId))
      .findFirst());
  }

  private static TaintVulnerabilityDto toDto(ServerTaintIssue serverTaintIssue, Predicate<Instant> isOnNewCode, FilePathTranslation translation, boolean isMQRMode,
    boolean isAiCodeFixable) {
    var cleanCodeAttribute = serverTaintIssue.getCleanCodeAttribute().map(attribute -> CleanCodeAttribute.valueOf(attribute.name())).orElse(null);
    var impacts = serverTaintIssue.getImpacts().entrySet().stream()
      .map(e -> new ImpactDto(SoftwareQuality.valueOf(e.getKey().name()),
        org.sonarsource.sonarlint.core.rpc.protocol.common.ImpactSeverity.valueOf(e.getValue().name())))
      .toList();
    var resolutionStatus = IssueMapper.mapStatus(serverTaintIssue.getResolutionStatus());
    return new TaintVulnerabilityDto(
      serverTaintIssue.getId(),
      serverTaintIssue.getSonarServerKey(),
      serverTaintIssue.isResolved(),
      resolutionStatus,
      serverTaintIssue.getRuleKey(),
      serverTaintIssue.getMessage(),
      translation.serverToIdePath(serverTaintIssue.getFilePath()),
      serverTaintIssue.getCreationDate(),
      // In practice, it could happen that the Clean Code Attribute is set but the impacts are empty.
      isMQRMode && !impacts.isEmpty() && cleanCodeAttribute != null
        ? Either.forRight(new MQRModeDetails(cleanCodeAttribute, impacts))
        : Either.forLeft(new StandardModeDetails(IssueSeverity.valueOf(serverTaintIssue.getSeverity().name()),
          RuleType.valueOf(serverTaintIssue.getType().name()))),
      toDto(serverTaintIssue.getFlows(), translation),
      TextRangeUtils.adapt(serverTaintIssue.getTextRange()),
      serverTaintIssue.getRuleDescriptionContextKey(),
      isOnNewCode.test(serverTaintIssue.getCreationDate()),
      isAiCodeFixable);
  }

  private boolean isAiCodeFixable(ServerTaintIssue serverTaintIssue, Binding binding) {
    return aiCodeFixRepository.get(binding.connectionId())
      .map(AiCodeFixService::aiCodeFixMapping)
      .filter(feature -> feature.isFeatureEnabled(binding.sonarProjectKey()))
      .map(AiCodeFixFeature::new)
      .map(feature -> feature.isFixable(serverTaintIssue))
      .orElse(false);
  }

  public static List<TaintVulnerabilityDto.FlowDto> toDto(List<ServerTaintIssue.Flow> flows, FilePathTranslation translation) {
    return flows.stream().map(flow -> new TaintVulnerabilityDto.FlowDto(
      flow.locations().stream()
        .map(location -> {
          var filePath = location.filePath();
          return new TaintVulnerabilityDto.FlowDto.LocationDto(TextRangeUtils.adapt(location.textRange()), location.message(),
            filePath == null ? null : translation.serverToIdePath(filePath));
        })
        .toList()))
      .toList();
  }

  private static List<ServerTaintIssue.Flow> adapt(List<TaintVulnerabilityRaisedEvent.Flow> flows) {
    return flows.stream().map(TaintVulnerabilityTrackingService::adapt).toList();
  }

  private static ServerTaintIssue.Flow adapt(TaintVulnerabilityRaisedEvent.Flow flow) {
    return new ServerTaintIssue.Flow(flow.getLocations().stream().map(TaintVulnerabilityTrackingService::adapt).toList());
  }

  private static ServerTaintIssue.ServerIssueLocation adapt(TaintVulnerabilityRaisedEvent.Location location) {
    return new ServerTaintIssue.ServerIssueLocation(
      location.getFilePath(),
      adapt(location.getTextRange()),
      location.getMessage());
  }

  public static TextRangeWithHash adapt(TaintVulnerabilityRaisedEvent.Location.TextRange range) {
    return new TextRangeWithHash(range.getStartLine(), range.getStartLineOffset(), range.getEndLine(), range.getEndLineOffset(), range.getHash());
  }
}
